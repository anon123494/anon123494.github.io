---
layout: post
title: A Barely Original Problem
date: '2024-04-13T12:53:00.000-07:00'
author: Banned In Iran
katex: true
---


<p style="text-align: left;">Being able to write is good. I want to get better at it and quite obviously the best way to get better is to write! However my desire to get better at writing is strongly overshadowed by my reluctance to write useless things, the internet is already so full of meaningless crap (at best and harmful crap at worst), and I'd hate to be one adding to it.</p><p style="text-align: left;">The only avenues where I'm capable of writing non-trivial stuff in are math and computer science, but triviality is a matter of perspective and anything I'd be writing about would already be written about considerably better than me by people who consider it trivial. The only way past seems to be to write about the one problem that I managed to come up with and this post is about that problem , it's solution and further generalizations of it</p><h2 style="text-align: left;">Next / Previous Video</h2><p style="text-align: left;">You're probably familiar with the next/previous function of a video players which opens the appropriate video file (most of the time alphabetically) coming after/before the current video. you may also be familiar with the <b>Recent </b>section that is shown when you right click on the video player in the taskbar listing around the 10 most recent files that have been opened by the video player
</p> 


![example of some recent files](/assets/img/Recent.jpg)


looking at this one day I got curious about how many possible permutations (or orderings) these files could get if you could only use the next or previous video function

## Formalizing the problem
imagine you have a folder with  <span class="katex"><math><semantics><mrow><mi>n</mi></mrow></semantics></math></span> video files numbered from <span class="katex"><math><semantics><mrow><mn>1</mn></mrow></semantics></math></span> to <span class="katex"><math><semantics><mrow><mi>n</mi></mrow></semantics></math></span>
and a video player with the file number <span class="katex"><math><semantics><mrow><mn>1</mn></mrow></semantics></math></span>.along with the folder we have a list of recently opened file ordered initially from <span class="katex"><math><semantics><mrow><mn>1</mn></mrow></semantics></math></span> to <span class="katex"><math><semantics><mrow><mi>n</mi></mrow></semantics></math></span> (here we consider all the files not just the 10 or so most recent) if the current opened file is numbered <span class="katex"><math><semantics><mrow><mi>i</mi></mrow></semantics></math></span> then you can open the next video: <span class="katex"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></semantics></math></span> (if you aren't at video <span class="katex"><math><semantics><mrow><mi>n</mi></mrow></semantics></math></span>) or you can open the previous video: <span class="katex"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></semantics></math></span> (if you aren't at video <span class="katex"><math><semantics><mrow><mn>1</mn></mrow></semantics></math></span>).

upon opening any file <span class="katex"><math><semantics><mrow><mi>i</mi></mrow></semantics></math></span> it goes to the top of the recent list and any video between it and the top gets shifted down. 

what are the number of distinct orderings the recent list can take by using an arbitrary (but obviously finite) number of steps (going to the previous or next file is one step)? [^1]

### Example
let <span class="katex"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow></semantics></math></span>. at step one we can only go from video <span class="katex"><math><semantics><mrow><mn>1</mn></mrow></semantics></math></span> (which is initially opened) to video <span class="katex"><math><semantics><mrow><mn>2</mn></mrow></semantics></math></span>  which would transform the recent list to <span class="katex"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></semantics></math></span>
if we then go to video <span class="katex"><math><semantics><mrow><mn>3</mn></mrow></semantics></math></span> we get the list <span class="katex"><math><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></semantics></math></span> and further returning <span class="katex"><math><semantics><mrow><mn>2</mn></mrow></semantics></math></span> (you can't get from <span class="katex"><math><semantics><mrow><mn>3</mn></mrow></semantics></math></span> to <span class="katex"><math><semantics><mrow><mn>1</mn></mrow></semantics></math></span>) would give us the list <span class="katex"><math><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></semantics></math></span>.

all of the three orderings above in addition to the initial <span class="katex"><math><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></semantics></math></span> ordering which is possible in <span class="katex"><math><semantics><mrow><mn>0</mn></mrow></semantics></math></span> steps! are distinct possible orderings and it just so happens that they are the only possible orderings (will be proven later). so the answer to the problem with <span class="katex"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow></semantics></math></span> is <span class="katex"><math><semantics><mrow><mn>4</mn></mrow></semantics></math></span>


### A final note
we can assume that the first steps are going from <span class="katex"><math><mrow><mn>1</mn></mrow></math></span> to <span class="katex"><math><mrow><mi>n</mi></mrow></math></span>  (with some next steps) and then back to <span class="katex"><math><mrow><mn>1</mn></mrow></math></span> (with some previous steps) this leaves us with the same starting list and at video 1 but it also means that we will open each file at least once (this will help us avoid some edge cases in the proof). so from this point every video will have been visited at least once

## Solution
the "trick" here is to think backwards and think about what possible videos can be at the end of the list when we finish. The simplest restriction is that the last time (name step <span class="katex"><math><mrow><mi>t</mi></mrow></math></span>) we  visit that video (which we name <span class="katex"><math><mrow><mi>i</mi></mrow></math></span> for now) it will be at the top of the list which means we have to open every single other video at least once without ever opening video <span class="katex"><math><mrow><mi>i</mi></mrow></math></span> again (since we assumed step <span class="katex"><math><mrow><mi>t</mi></mrow></math></span> was the last time <span class="katex"><math><mrow><mi>i</mi></mrow></math></span> was opened) . however this is impoosible if we have 
<span class="katex"><math><mrow><mn>1</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow></math></span>. since if we choose next at step (<span class="katex"><math><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></math></span>) we won't be able to open video <span class="katex"><math><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></math></span> without first opening vidoe <span class="katex"><math><mrow><mi>i</mi></mrow></math></span> at least once (since we can only "move"  one video at a time) ; and if we choose previous then we can't ever open video <span class="katex"><math><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></math></span>. this means that the only possible last videos in our list are videos <span class="katex"><math><mrow><mn>1</mn></mrow></math></span> and <span class="katex"><math><mrow><mi>n</mi></mrow></math></span>.

applying the same reasoning as above gives us that we can also two possible videos as our __second__ last video (either <span class="katex"><math><mrow><mn>1</mn></mrow></math></span> and <span class="katex"><math><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></math></span> if we chose <span class="katex"><math><mrow><mi>n</mi></mrow></math></span> as out last or <span class="katex"><math><mrow><mn>2</mn></mrow></math></span> and <span class="katex"><math><mrow><mi>n</mi></mrow></math></span> if we chose <span class="katex"><math><mrow><mn>1</mn></mrow></math></span> as our last).continuing we have have two possible choices for every 'next' last video until we're left with only one possible video for the most recently watched. since it takes exactly <span class="katex"><math><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></math></span> steps (<span class="katex"><math><mrow><mi>n</mi><mo>≥</mo><mn>2</mn></mrow></math></span>) to determine every video of the list (we choose from two at every step until there's only one vieo remaining) and we have exactly 2 choices as each step the number of possible orderings[2^] is <span class="katex"><math><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow></math></span> by the rule of product 

## Coming soon ...
in the unpcoming post(s) i will present and solve some more generalized forms of this problem (what if we had 2 video players open etc...).

Disclaimer: the __Coming soon__ part will only be true if i don't slack off which isn't certain considering how lazy i am


[^1]: there are other possible formalizations but this one suffices (and we will use more general forms laters)
[^2]: We should also prove that each different list of choices results in a different ordering (so that the 'mapping' we have made between permutations and lists of choices is one to one). but that is trivial (consider the first step which to lists of choices differ)